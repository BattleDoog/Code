<!DOCTYPE html>
<html>
	<head>
		<title>Space</title>
		<style type="text/css">
			#mainCanv{
				background-color:black;
			}
		</style>
	</head>
	<body>
		<canvas id="mainCanv" width="1400" height="750"></canvas>
		<script type="text/javascript">
			var mainCanv = document.getElementById("mainCanv");
			var ctx = mainCanv.getContext("2d");

			var gridSpace = 75;

			var worldWidth = 10000;
			var worldHeight = 10000;

			var canvWidth = mainCanv.width;
			var canvHeight = mainCanv.height;

			//character
			var centerX = 17; //approximate values, dependent on draw func
			var centerY = 24;
			var charX = worldWidth/2;
			var charY = worldHeight/2;
			var rotation = 0;
			var totalMass = 30;
			var charModel;
			var omega = 0; //angular velocity
			var vX = 0; //linear x vel
			var vY = 0; //linear y vel

			var leftForwardEngine = {x:2, y:42, fX:0, fY:-5};
			var rightForwardEngine = {x:32, y:42, fX:0, fY:-5};

			var backwardsEngine = {x:17, y:2, fX:0, fY:5};

			var dT = 0.3; //timestep

			var aDown = false;
			var dDown = false;
			var wDown = false;
			var sDown = false;

			var init;

			function renderFunction(width, height, renderFunction) {
			    var buffer = document.createElement('canvas');
			    buffer.width = width;
			    buffer.height = height;
			    renderFunction(buffer.getContext('2d'));
			    return buffer;
			}

			//create character model
			charModel = renderFunction(34, 44, function (ctx){
				ctx.beginPath();
				ctx.moveTo(2,42);
				ctx.lineTo(17,2);
				ctx.lineTo(32,42);
				ctx.arc(17,48,15,-Math.PI/4+Math.PI/5,-3*Math.PI/4-Math.PI/5,true);
				ctx.closePath();
				ctx.strokeStyle = "white";
				ctx.lineWidth = 3;
				ctx.stroke();
				ctx.fillStyle = "red";
				ctx.beginPath();
				ctx.moveTo(leftForwardEngine.x, leftForwardEngine.y);
				ctx.arc(leftForwardEngine.x, leftForwardEngine.y, 2, 0, Math.PI*2, true);
				ctx.moveTo(rightForwardEngine.x, rightForwardEngine.y);
				ctx.arc(rightForwardEngine.x, rightForwardEngine.y, 2, 0, Math.PI*2, true);
				ctx.moveTo(backwardsEngine.x, backwardsEngine.y);
				ctx.arc(backwardsEngine.x, backwardsEngine.y, 2, 0, Math.PI*2, true);
				ctx.closePath();
				ctx.fill();
			});

			ctx.drawImage(charModel, canvWidth/2, canvHeight/2);

			function drawGrid(x,y){
				var xOff = (x - canvWidth/2) % gridSpace;
				var yOff = (y - canvHeight/2) % gridSpace;

				var xLinesToDraw = canvWidth/gridSpace;
				var yLinesToDraw = canvHeight/gridSpace;

				ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
				ctx.lineWidth = 2;

				ctx.beginPath();

				for (var i = -1; i < xLinesToDraw + 1; i++){
					ctx.moveTo(gridSpace*i - xOff, 0);
					ctx.lineTo(gridSpace*i - xOff, canvHeight);
				}

				for (var i = -1; i < yLinesToDraw + 1; i++){
					ctx.moveTo(0, gridSpace*i - yOff);
					ctx.lineTo(canvWidth, gridSpace*i - yOff);
				}

				ctx.moveTo(xOff, 0);
				ctx.closePath();

				ctx.stroke();

				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.strokeStyle = "white";

				if (y < canvHeight/2){ //upper left corner
					ctx.moveTo(0, canvHeight/2 - y);
					ctx.lineTo(canvWidth, canvHeight/2 - y);
					ctx.moveTo(0, canvHeight/2 - y);
				} else if (y > worldHeight - canvHeight/2) { //lower left corner
					ctx.moveTo(0, worldHeight + canvHeight/2 - y);
					ctx.lineTo(canvWidth, worldHeight + canvHeight/2 - y);
					ctx.moveTo(0, worldHeight + canvHeight/2 - y);
				}

				if (x < canvWidth/2){
					ctx.moveTo(canvWidth/2 - x, 0);
					ctx.lineTo(canvWidth/2 - x, canvHeight);
					ctx.moveTo(canvWidth/2 - x, 0);
				} else if (x > worldWidth - canvWidth/2){
					ctx.moveTo(worldWidth + canvWidth/2 - x, 0);
					ctx.lineTo(worldWidth + canvWidth/2 - x, canvHeight);
					ctx.moveTo(worldWidth + canvWidth/2 - x, 0);
				}

				ctx.closePath();
				ctx.stroke();
			}

			function checkKeysDown(e){
				if (e.keyCode == 65){
					aDown = true;
				}
				if (e.keyCode == 68){
					dDown = true;
				}
				if (e.keyCode == 87){
					wDown = true;
				}
				if (e.keyCode == 83){
					sDown = true;
				}
			}

			function checkKeysUp(e){
				if (e.keyCode == 65){
					aDown = false;
				}
				if (e.keyCode == 68){
					dDown = false;
				}
				if (e.keyCode == 87){
					wDown = false;
				}
				if (e.keyCode == 83){
					sDown = false;
				}
			}

			function applyForce(fCX, fCY, fX, fY, mFC){ //fCX and FCY are the distances from point of force to center of mass. fX and fY is the force. Returns an object: {projX:..., projY:..., orth:..., r:...} Towards is the amount of force towards the center of mass, normal is the amount normal to it, r is the distance from the force to the center. Also takes magnitude of FC, which is optional. It will be ignored if it is 0.
				//rotate force vectors for direction of ship

				var mag = 1;
				if (mFC === 0){
					var magSquared = fCX*fCX + fCY*fCY;
					if (magSquared === 0){
						return false;
					} else {
						mag = Math.sqrt(magSquared);
					}
				} else {
					mag = mFC;
				}

				var dot = fX*fCX + fY*fCY;
				var proj = dot/mag;

				var orth = Math.sqrt (fX*fX + fY*fY - proj*proj);
				var crossZ = fCX*fY - fCY*fX;
				if (crossZ < 0){
					orth *= -1;
				}

				var projX = proj/mag * fCX;
				var projY = proj/mag * fCY;

				changeVels(projX, projY, orth, mag);

				/*
				dot product = fX*fCX + fY*fCY

				projection of f onto fC = dot product / magnitude fC
				orthagonal of f onto fC = sqrt (magSquared - proj*proj)
				*/
			}

			function changeVels(projX, projY, orth, r){
				//w looks kinda like omega :P
				//l means linear
				var aW = orth/totalMass;
				var aLX = projX/totalMass;
				var aLY = projY/totalMass; 

				var dir = Math.atan2(aLY, aLX);
				rotation = rotation % Math.PI*2;

				var aLR = aLX*aLX + aLY*aLY;
				aLX = aLR * Math.cos(dir+rotation + Math.PI/2);
				aLY = aLR * Math.sin(dir + rotation + Math.PI/2);*/

				omega += aW*dT/r;
				vX += aLX*dT;
				vY += aLY*dT;
			}

			function update(){
				if (wDown){
					applyForce(leftForwardEngine.x-centerX, leftForwardEngine.y-centerY, leftForwardEngine.fX, leftForwardEngine.fY, 0);
					applyForce(rightForwardEngine.x-centerX, rightForwardEngine.y-centerY, rightForwardEngine.fX, rightForwardEngine.fY, 0);
				}
				if (sDown){
					applyForce(backwardsEngine.x-centerX, backwardsEngine.y-centerY, backwardsEngine.fX, backwardsEngine.fY, 0);
				}
				if (dDown){
					applyForce(leftForwardEngine.x-centerX, leftForwardEngine.y-centerY, leftForwardEngine.fX, leftForwardEngine.fY, 0);
				}
				if (aDown){
					applyForce(rightForwardEngine.x-centerX, rightForwardEngine.y-centerY, rightForwardEngine.fX, rightForwardEngine.fY, 0);
				}
				charX += vX;
				charY += vY;
				rotation += omega;

				ctx.clearRect(0,0,canvWidth,canvHeight);
				drawRotatedImage(charModel, canvWidth/2, canvHeight/2, rotation);
				drawGrid(charX,charY);
			}

			function drawRotatedImage(image, x, y, angle) { 
			 
				// save the current co-ordinate system 
				// before we screw with it
				ctx.save(); 
			 
				// move to the middle of where we want to draw our image
				ctx.translate(x, y);
			 
				// rotate around that point
				ctx.rotate(angle);
			 
				// draw it up and to the left by half the width
				// and height of the image 
				ctx.drawImage(image, -(image.width/2), -(image.height/2));
			 
				// and restore the co-ords to how they were when we began
				ctx.restore(); 
			}

			init = setInterval(update, 20);

			document.body.onkeydown = checkKeysDown;
			document.body.onkeyup = checkKeysUp;
		</script>
	</body>
</html>